using SymbolicPlanners: PathNode
const SearchTree = Dict{UInt64, PathNode{GenericState}}

function sample_trace(domain, problem, depth, forward_traces, backward_traces)
	!forward_traces && !backward_traces && error("either forward_traces or backward_traces has to be true")
	forward_traces && !backward_traces && return(sample_forward_trace(domain, problem, depth))
	!forward_traces && backward_traces && return(sample_backward_trace(domain, problem, depth))
	return(rand([true,false]) ? sample_forward_trace(domain, problem, depth) : sample_backward_trace(domain, problem, depth))
end

"""
(trajectory, plan) = sample_backward_trace(domain, problem, depth; full_states = true, remove_cycles = true)
(trajectory, plan) = sample_backward_trace(domain, problem, goal_state, depth; full_states = true, remove_cycles = true)

random trace ending in `goal_state = goalstate(domain, problem)` generated by 
`regress`ing the goal_state

full_states --- returned trajectory is replayed by `simulate(StateRecorder(), domain, state, plan)` returning more
			complete states then partial states 
remove_cycles --- remove cycles from the trajectory (and plan)
"""
function sample_backward_trace(domain, problem, depth; full_states = true, remove_cycles = true)
	sample_backward_trace(domain, problem, goalstate(domain, problem), depth; full_states, remove_cycles)
end

function sample_backward_trace(domain, problem, goal_state, depth; full_states = true, remove_cycles = true)
	state = goal_state
	plan = []
	trajectory = [state]
	for i in 1:depth
		acts = relevant(domain, state)
		isempty(acts) && break 
		act = rand(acts)
		next_state = regress(domain, state, act; check=false)
		push!(trajectory, next_state)
		push!(plan, act)
		state = next_state
	end
	trajectory, plan = reverse(trajectory), reverse(plan)
	if full_states
		trajectory = SymbolicPlanners.simulate(StateRecorder(), domain, state, plan)
	end
	if remove_cycles
		trajectory, plan =  removecycles(trajectory, plan)
	end
	!issubset(goal_state, last(trajectory)) && error("Something went terribly wrong, goal_state is not last in trajectory. File an issue.")
	return(trajectory, plan)
end

"""
search_tree = sample_backward_tree(domain, problem; max_depth = 30, max_leaves=10_000, max_states=100_000)
search_tree = sample_backward_tree(domain, problem, goal_state; max_depth = 30, max_leaves=10_000, max_states=100_000)

random search_tree of backward search, which means that the root node ends 
in `goal_state = goalstate(domain, problem).` Tree is generated by 
`regress`ing the state. Cycles are not detected. 

max_depth --- maximum depth of the node to be expanded
max_leaves --- maximum number of states in the open set (corrends to leafs)
max_states --- maximum number of states in the search tree
"""
function sample_backward_tree(domain, problem; max_depth = 30, max_states=100_000)
	goal_state =  goalstate(domain, problem)
	sample_backward_tree(domain, problem, goal_state;max_depth, max_states)
end

function sample_backward_tree(domain, problem, goal_state; max_depth = 30, max_states=100_000)
	state = goal_state
	node_id = hash(state)
	search_tree = Dict(node_id => PathNode(node_id, state, 0.0))
	open_states = Set([node_id])
	expanded_states = 0
	while !isempty(open_states)
		node_id = rand(open_states)
		pop!(open_states, node_id)
		state = search_tree[node_id].state
		g = search_tree[node_id].path_cost
		acts = relevant(domain, state)
		expanded_states += 1
		for act in acts
			next_state = regress(domain, state, act; check=false)
			next_id = hash(next_state)
			next_id ∈ keys(search_tree) && continue
			search_tree[next_id] = PathNode(next_id, next_state, g + 1, node_id, act)
			push!(open_states, next_id)
		end
		length(search_tree) ≥ max_states && break
	end
	println("open states: ",length(open_states), " search tree: ", length(search_tree), " expanded states: ",expanded_states," max depth: ",maximum(s.path_cost for s in values(search_tree)))
	search_tree
end

function sample_backward_trace(domain, search_tree::Dict; full_states = true)
	sample_backward_trace(search_tree, leafs(search_tree); full_states)
end

function sample_backward_trace(domain, search_tree::Dict, l; full_states = true)
	id = rand(l)
	trajectory =  Vector{GenericState}()
	plan =  []
	while(true)
		v = search_tree[id]
		push!(trajectory, v.state)
		v.parent_id === nothing && break
		push!(plan, v.parent_action)
		id = v.parent_id
	end
	if full_states
		state = first(trajectory)
		trajectory = SymbolicPlanners.simulate(StateRecorder(), domain, state, plan)
	end
	trajectory, plan
end


struct BackwardSampler{D,S<:Dict,L,F}
	domain::D
	search_tree::S
	lists::L
	full_states::Bool
	sample_goal::Bool
	fminibatch::F
end

function BackwardSampler(domain, search_tree; full_states = true, sample_goal = false, fminibatch = identity)

end



"""
(trajectory, plan) = sample_forward_trace(domain, problem, depth; full_states = true, remove_cycles = true)
(trajectory, plan) = sample_forward_trace(domain, problem, initial_state, depth; full_states = true, remove_cycles = true)

random trace starting in `initial_state = initstate(domain, problem)` generated by 
expanding the initial state

full_states --- returned trajectory is replayed by `simulate(StateRecorder(), domain, state, plan)` returning more
			complete states then partial states 
remove_cycles --- remove cycles from the trajectory (and plan)
"""
function sample_forward_trace(domain, problem, depth; remove_cycles = true)
	sample_forward_trace(domain, problem, initstate(domain, problem), depth; remove_cycles)
end

function sample_forward_trace(domain, problem, initial_state, depth; remove_cycles = true)
	state = initial_state
	plan = []
	trajectory = [state]
	for i in 1:depth
		acts = available(domain, state)
		isempty(acts) && break 
		act = rand(acts)
		next_state = execute(domain, state, act; check=false)
		push!(trajectory, next_state)
		push!(plan, act)
		state = next_state
	end
	if remove_cycles
		trajectory, plan =  removecycles(trajectory, plan)
	end
	return(trajectory, plan)
end

function search_tree_from_trajectory(domain, trajectory, plan)
	state = first(trajectory)

	node_id = hash(state)
	search_tree = Dict(node_id => PathNode(node_id, state, 0))
	for (i, state) in enumerate(trajectory[1:end-1])
		add_descendants!(search_tree, domain, state, i - 1)
	end
	@assert all(haskey(search_tree, hash(s)) for s in trajectory)
	search_tree
end

function add_descendants!(search_tree::SearchTree, domain, state, g)
	parent_id = hash(state)
    for act in available(domain, state)
        next_state = execute(domain, state, act; check=false)
        node_id = hash(next_state)
        get!(search_tree, node_id, PathNode(node_id, next_state, g+1, parent_id, act))
    end
    search_tree
end

function firstcycle(trajectory)
	cycles = Int[]
	for i in eachindex(trajectory)
		for j in i+1:lastindex(trajectory)
			trajectory[i] == trajectory[j] && push!(cycles, i)
		end 
	end
	isempty(cycles) && return(nothing)
	return(maximum(cycles))
end

function removecycles(trajectory, plan)
	j = firstcycle(trajectory)
	j == nothing && return(trajectory, plan)
	@assert j < length(trajectory)
	j = j + 1
	trajectory[j:end], plan[j:end]
end
