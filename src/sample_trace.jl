using SymbolicPlanners: PathNode
const SearchTree = Dict{UInt64, PathNode{GenericState}}

function sample_trace(domain, problem, depth, forward_traces, backward_traces)
	!forward_traces && !backward_traces && error("either forward_traces or backward_traces has to be true")
	forward_traces && !backward_traces && return(random_forward_trace(domain, problem, depth))
	!forward_traces && backward_traces && return(random_backward_trace(domain, problem, depth))
	return(rand([true,false]) ? random_forward_trace(domain, problem, depth) : random_backward_trace(domain, problem, depth))
end

"""
(trajectory, plan) = random_backward_trace(domain, problem, depth; full_states = true, remove_cycles = true)
(trajectory, plan) = random_backward_trace(domain, problem, goal_state, depth; full_states = true, remove_cycles = true)

random trace ending in `goal_state = goalstate(domain, problem)` generated by 
`regress`ing the goal_state

full_states --- returned trajectory is replayed by `simulate(StateRecorder(), domain, state, plan)` returning more
			complete states then partial states 
remove_cycles --- remove cycles from the trajectory (and plan)
"""
function random_backward_trace(domain, problem, depth; full_states = true, remove_cycles = true)
	random_backward_trace(domain, problem, goalstate(domain, problem), depth; full_states, remove_cycles)
end

function random_backward_trace(domain, problem, goal_state, depth; full_states = true, remove_cycles = true)
	state = goal_state
	plan = []
	trajectory = [state]
	for i in 1:depth
		acts = relevant(domain, state)
		isempty(acts) && break 
		act = rand(acts)
		next_state = regress(domain, state, act; check=false)
		push!(trajectory, next_state)
		push!(plan, act)
		state = next_state
	end
	trajectory, plan = reverse(trajectory), reverse(plan)
	if full_states
		trajectory = SymbolicPlanners.simulate(StateRecorder(), domain, state, plan)
	end
	if remove_cycles
		trajectory, plan =  removecycles(trajectory, plan)
	end
	!issubset(goal_state, last(trajectory)) && error("Something went terribly wrong, goal_state is not last in trajectory. File an issue.")
	return(trajectory, plan)
end


"""
(trajectory, plan) = random_forward_trace(domain, problem, depth; full_states = true, remove_cycles = true)
(trajectory, plan) = random_forward_trace(domain, problem, initial_state, depth; full_states = true, remove_cycles = true)

random trace starting in `initial_state = initstate(domain, problem)` generated by 
expanding the initial state

full_states --- returned trajectory is replayed by `simulate(StateRecorder(), domain, state, plan)` returning more
			complete states then partial states 
remove_cycles --- remove cycles from the trajectory (and plan)
"""
function random_forward_trace(domain, problem, depth; remove_cycles = true)
	random_forward_trace(domain, problem, initstate(domain, problem), depth; remove_cycles)
end

function random_forward_trace(domain, problem, initial_state, depth; remove_cycles = true)
	state = initial_state
	plan = []
	trajectory = [state]
	for i in 1:depth
		acts = available(domain, state)
		isempty(acts) && break 
		act = rand(acts)
		next_state = execute(domain, state, act; check=false)
		push!(trajectory, next_state)
		push!(plan, act)
		state = next_state
	end
	if remove_cycles
		trajectory, plan =  removecycles(trajectory, plan)
	end
	return(trajectory, plan)
end

function search_tree_from_trajectory(domain, trajectory, plan)
	state = first(trajectory)

	node_id = hash(state)
	search_tree = Dict(node_id => PathNode(node_id, state, 0))
	for (i, state) in enumerate(trajectory[1:end-1])
		add_descendants!(search_tree, domain, state, i - 1)
	end
	@assert all(haskey(search_tree, hash(s)) for s in trajectory)
	search_tree
end

function add_descendants!(search_tree::SearchTree, domain, state, g)
	parent_id = hash(state)
    for act in available(domain, state)
        next_state = execute(domain, state, act; check=false)
        node_id = hash(next_state)
        get!(search_tree, node_id, PathNode(node_id, next_state, g+1, parent_id, act))
    end
    search_tree
end

function firstcycle(trajectory)
	cycles = Int[]
	for i in eachindex(trajectory)
		for j in i+1:lastindex(trajectory)
			trajectory[i] == trajectory[j] && push!(cycles, i)
		end 
	end
	isempty(cycles) && return(nothing)
	return(maximum(cycles))
end

function removecycles(trajectory, plan)
	j = firstcycle(trajectory)
	j == nothing && return(trajectory, plan)
	@assert j < length(trajectory)
	j = j + 1
	trajectory[j:end], plan[j:end]
end
